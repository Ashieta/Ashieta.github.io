<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>届かない恋</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-07-21T14:43:07.308Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Shao Jiang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ViDeZZo源码与实现思路</title>
    <link href="http://example.com/2023/07/21/ViDeZZo%E6%BA%90%E7%A0%81%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/"/>
    <id>http://example.com/2023/07/21/ViDeZZo%E6%BA%90%E7%A0%81%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</id>
    <published>2023-07-21T14:42:34.000Z</published>
    <updated>2023-07-21T14:43:07.308Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纪念我的第二篇Blog，第一篇有我的idea就不放出来了。</p><p>纪念浙江大学玉泉校区曹主楼320的橙色暴雨预警的深夜。</p><p>给个书读吧求求了。——js 7.21</p></blockquote><h2 id="编译构建"><a href="#编译构建" class="headerlink" title="编译构建"></a>编译构建</h2><ol><li>编译命令：make qemu qemu-coverage</li></ol><p>当前目录中的make videzzo-core</p><ol start="2"><li>make videzzo-core</li></ol><p>运行videzzo_types_gen.py</p><p>videzzo_tool中的all（做merge和产生PoC的，先忽略掉）</p><p>编译videzzo.c和videzzo_types.c，打包成静态库</p><ol start="3"><li>videzzo_qemu目录中的make qemu clusterfuzz还有qemu-coverage clusterfuzz-coverage</li></ol><p>qemu-dep安装依赖并且下载qemu；make patch。</p><p>make patch：把patch脚本复制到qemu源码中并执行patch。这个patch看上去像是qtest框架的东西。</p><p>make compile：</p><p>执行copy脚本把当前目录下的videzzo_qemu.c以及videzzo_qemu_types.yaml以及之前编译好的库放到qemu源文件的qtest文件夹下。</p><ol start="4"><li>cluster-fuzz</li></ol><p>这里抄的qemu的oss-fuzz，为的是不带参数直接运行对目标的fuzz文件。我感觉这么处理是为了满足OSS-Fuzz的要求。qemu-fuzzer的编译脚本有这么写：</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230721204119561.png" alt="image-20230721204119561"></p><h2 id="QTest——QEMU自带单元测试框架"><a href="#QTest——QEMU自带单元测试框架" class="headerlink" title="QTest——QEMU自带单元测试框架"></a>QTest——QEMU自带单元测试框架</h2><p>为什么再一次看qtest，（上一次看没看下去），是因为ViDeZZo确实很难看懂。虽然author在paper中闪烁其词，我还是能看出来他们参考了很多Morphuzz的实现思路的，所以这里回来看一下qtest和qemufuzzer。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://qemu.readthedocs.io/en/latest/devel/qtest.html">QTest Device Emulation Testing Framework — QEMU 8.0.0 documentation</a></p><p>qtest用于对qemu虚拟设备进行单元测试。qtest本质上是一个库，源码在<code>tests/qtest/libqtest.c</code>，<code>tests/qtest/libqtest.h</code>中定义了可用的API。另外在libqtest上还有一个libqos，往往更常用（On top of libqtest, a higher level library, <code>libqos</code>, was created to encapsulate common tasks of device drivers, such as memory management and communicating with system buses or devices. 这个还能测driver？？ 这里值得研究）。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>最基本的使用方式。</p><p>需要自己用<code>glib and libqtest/libqos API</code>编写测试脚本放到tests&#x2F;qtest&#x2F; 下面，在<code>tests/qtest/meson.build</code>加入这个脚本的编译，在相关的架构变量下面加上测试用例。运行这个测试用例的方式为make check-qtest。</p><p>理论上qtest框架只是包含上述的内容，当我想看一个例子：qemu&#x2F;tests&#x2F;qtest&#x2F;ac97-test.c的时候，我发现文档说的没错——基本上要用libqos。这里我们再看一下liboqs的相关文档。</p><h3 id="Qtest-Driver-Framework"><a href="#Qtest-Driver-Framework" class="headerlink" title="Qtest Driver Framework"></a>Qtest Driver Framework</h3><p><a href="https://qemu.readthedocs.io/en/latest/devel/qgraph.html#">Qtest Driver Framework — QEMU 8.0.0 documentation</a></p><p>使用QGraph组织测试。</p><p>文档写的什么史，根本看不懂。</p><h3 id="QEMU-Fuzzing"><a href="#QEMU-Fuzzing" class="headerlink" title="QEMU-Fuzzing"></a>QEMU-Fuzzing</h3><p><a href="https://qemu.readthedocs.io/en/latest/devel/fuzzing.html">Fuzzing — QEMU 8.0.0 documentation</a></p><p>这个文档和相关的代码应该是Alexander写的，Morphuzz的一作，这篇paper应该也是来源于此。</p><ol><li>Fuzzer的使用</li></ol><p>编译：configure的时候–enable-fuzzing 之后 make qemu-fuzz-i386。</p><p>编译出来之后，.&#x2F;qemu-fuzz-i386不带参数会显示可测的目标，添加–fuzz-target&#x3D;FUZZ_NAME参数开始测试。</p><p>注意，因为有&#x2F;fuzz&#x2F;virtio_scsi_fuzz.c这个文件，才能有.&#x2F;qemu-fuzz-i386 –fuzz-target&#x3D;virtio-scsi-fuzz这个fuzzer。</p><ol start="2"><li>Fuzzer的添加</li></ol><p>感觉和qtest一样的，用LLVM+libqtest&#x2F;libqos API去写，放到tests&#x2F;qtest&#x2F;fuzz&#x2F; 下面，在编译框架中加上。*这里的Fuzzer都是ad-hoc的，对每一个设备单独写。</p><p>有一个特殊的generic-fuzz，通过给环境变量给参数从而Fuzz目标设备，比如这样给参数：<img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230721221541450.png" alt="image-20230721221541450"></p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230721221548048.png" alt="image-20230721221548048"></p><ol start="3"><li>0SS-Fuzz</li></ol><p>这下能看懂ViDeZZo的一些奇怪代码和编译指令了，原来是源自这里！</p><p>因为generic-fuzz需要环境变量，为了不用环境变量直接是一个可执行文件的形式（可能是为了加入OSS-Fuzz吧），tests&#x2F;qtest&#x2F;fuzz&#x2F;generic_fuzz_configs.h这里面给了一些配置。build的方法也给出来了：<img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230721222012503.png" alt="image-20230721222012503"></p><p>ViDeZZo直<a href="https://github.com/HexHive/ViDeZZo/tree/master/videzzo_qemu">videzzo_qemu</a>&#x2F;videzzo_qemu.c应该是参考这里写的。</p><ol start="4"><li>实现原理</li></ol><p>整体的原理在fuzz.c里面，相当于一个Framework。框架的入口点在这里：</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230721222633817.png" alt="image-20230721222633817"></p><p>这里fuzz_target-&gt;fuzz()不出意外就是自定义的ad-hoc fuzzer或者那个generic-fuzzer提供的一个回调，用于对目标设备执行一次模糊行为。在实现模糊行为的过程中，Qemuphuzz（为什么我突然这么叫了？因为这里我去看了paper，发现标准的叫法应该是这个 ：）强烈谴责ViDeZZo作者的不严谨）首先将libfuzzer产生的字节码解码成IO操作，之后利用libqos和libqtest与设备进行交互。</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230721222309272.png" alt="image-20230721222309272"></p><p>具体怎么交互的参考paper的section 4.4.2。 连上了，都连上了！</p><p>这么看来，ViDeZZo几乎重写了Qemuphuzz的框架，基本的执行流也是一样的。</p><h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><p>绕得有点远，应该回来了，我们的正题是ViDeZZo。但是因为想回去吃夜宵了，下次再看源码。</p><p>待续。****</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;纪念我的第二篇Blog，第一篇有我的idea就不放出来了。&lt;/p&gt;
&lt;p&gt;纪念浙江大学玉泉校区曹主楼320的橙色暴雨预警的深夜。&lt;/p&gt;
&lt;p&gt;给个书读吧求求了。——js 7.21&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;编译构建&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="Virtual Device Fuzzing" scheme="http://example.com/tags/Virtual-Device-Fuzzing/"/>
    
  </entry>
  
  <entry>
    <title>IO设备与驱动：原理与代码</title>
    <link href="http://example.com/2023/07/17/IO%E8%AE%BE%E5%A4%87%E4%B8%8E%E9%A9%B1%E5%8A%A8%EF%BC%9A%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    <id>http://example.com/2023/07/17/IO%E8%AE%BE%E5%A4%87%E4%B8%8E%E9%A9%B1%E5%8A%A8%EF%BC%9A%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BB%A3%E7%A0%81/</id>
    <published>2023-07-17T12:24:45.000Z</published>
    <updated>2023-07-21T14:43:50.369Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>At the lowest level, a piece of software in the OS must know in detail<br>how a device works. We call this piece of software a device driver, and<br>any specifics of device interaction are encapsulated within.  –《OSTEP》</p><p>人生的第一篇Blog，纪念我在ZJU进行的夏令营Project。 –JS</p></blockquote><p>本文关注主机在最低层次上与IO设备的交互，主要包括我对于设备驱动实现、驱动-设备Interface、设备Semantics的一些想法，内容涉及一些设备驱动的原理与代码实现。终极目标为探索Driver在Virtual Device Fuzzing中的用武之地。</p><h1 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h1><p>众所周知，在计算机视角下IO设备可以被建模为一些寄存器的集合，OS与设备的交互在最底层体现为严格按照硬件Spec的一系列Reg级别IO操作序列。又众所周知，为了保证操作系统的Device-neutral以及scalability，操作系统与IO设备的交互最终是由Driver完成的。Driver向上为OS提供API，向下根据Hardware Spec完成设备操作。</p><h1 id="Case-Study-1：IDE-Disk-Driver-in-xv6"><a href="#Case-Study-1：IDE-Disk-Driver-in-xv6" class="headerlink" title="Case Study 1：IDE Disk Driver in xv6"></a>Case Study 1：IDE Disk Driver in xv6</h1><p>该例子在大名鼎鼎的<a href="https://pages.cs.wisc.edu/~remzi/OSTEP/file-devices.pdf">OSTEP</a>中已经得到了详尽的解释。值得注意的是，这个例子中IDE磁盘控制器不需要DMA，仅通过PIO完成磁盘的read、write。设备语法在这个例子中体现为寄存器类型（本质上为IO地址）、IO指令依赖关系（）。</p><h1 id="Case-Study-2：UART-Hardware-＆-Driver-in-xv6"><a href="#Case-Study-2：UART-Hardware-＆-Driver-in-xv6" class="headerlink" title="Case Study 2：UART Hardware ＆ Driver in xv6"></a>Case Study 2：UART Hardware ＆ Driver in xv6</h1><p>UART也是仅仅支持PIO.</p><h1 id="Case-Study-3：e1000-Driver-in-xv6-＆-Linux"><a href="#Case-Study-3：e1000-Driver-in-xv6-＆-Linux" class="headerlink" title="Case Study 3：e1000 Driver in xv6 ＆ Linux"></a>Case Study 3：e1000 Driver in xv6 ＆ Linux</h1><p>该例子来源于MIT 6.S081的<a href="https://pdos.csail.mit.edu/6.S081/2021/labs/net.html">Lab: networking</a>。</p><h2 id="E1000驱动核心函数的简单原理（in-xv6）"><a href="#E1000驱动核心函数的简单原理（in-xv6）" class="headerlink" title="E1000驱动核心函数的简单原理（in xv6）"></a>E1000驱动核心函数的简单原理（in xv6）</h2><blockquote><p>这一部分是对于这个lab的guidance的总结, 包括了E1000驱动的基本原理.</p></blockquote><p>e1000_init()：完成DMA Buffer的配置。驱动在内存中设置了多个硬件可以直接通过DMA读写的Buffer，接受Buffer的描述符为struct rx_desc，这些描述符构成环形队列即receive ring。</p><p>mbuf：是内核网络协议栈中传递和处理数据包的重要数据结构之一。也就是存储网络包的数据结构。在Linux中对应的应该是struct sk_buff *skb。skb在网络协议栈中有两个流动方向，”对于TX来说，传输层申请SKB，设备驱动释放SKB；对于RX来说，设备驱动申请SKB，网络协议栈TCP&#x2F;IP Stack 负责释放之“。</p><p>e1000_transmit()：发包函数，传入参数为一个描述要发送数据包的mbuf。发包函数需要完成的任务是把指向这个数据包的struct tx_desc放到TX ring上。</p><p>e1000_recv（）：收包函数，我认为应该是一个中断处理函数。E1000受到包的时候会将数据DMA到RX_ring中当前可用的mbuf中并引发中断。之后由e1000_recv（）通过调用net_RX（）将这个包发送到上层堆栈，最后分配一个新的mbuf放到RX RING中以供接下来受到的包。</p><p>除了上述DMA层面的语法，驱动还需要通过MMIO的控制regs与设备交互。通过与控制reg的交互，驱动可以获得E1000受到包的信息，可以通知E1000驱动已经向TX写入了需要发的包。</p><h2 id="E1000网卡硬件规范以及驱动详解"><a href="#E1000网卡硬件规范以及驱动详解" class="headerlink" title="E1000网卡硬件规范以及驱动详解"></a>E1000网卡硬件规范以及驱动详解</h2><blockquote><p>来自于<a href="https://blog.csdn.net/u010180372/article/details/119525638">博客</a>，以及E1000手册。</p></blockquote><p>我们的目标是从整体上把握E1000设备以及Driver的初始化以及使用过程。故事要从PCI开始。</p><h3 id="PCI相关知识"><a href="#PCI相关知识" class="headerlink" title="PCI相关知识"></a>PCI相关知识</h3><p>E1000设备首先是一个PCI设备，符合PCI设备配置规范，也就是经典的PCI配置空间寄存器表。</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230718155855758.png" alt="image-20230718155855758"></p><p>这里插一点PCI系统的architecture，PCI通过PCI-PCI桥或者其他桥（也是一种PCI设备）构成一个树状结构。PCI bus 0是关键、必要的PCI总线，通过Host Bridge（北桥芯片的一种)与CPU相连。从最开始的PCI bus0 only到完整的PCI设备树，需要通过<strong>PCI总线枚举</strong>的过程。在枚举过程中读取并配置PCI配置寄存器。注意MMIO地址就是在PCI总线枚举过程中配置的。总而言之，PCI完成了设备寄存器到主存空间的映射。</p><p>The Base Address Registers (or BARs) are used to map the Ethernet con-troller’s register space and flash to system memory space.</p><p>SDM的Section 2.8中提到，有关Buffer（DMA）的软硬件界限。这里的软件为driver，硬件自然就为E1000硬件。也就是说，DMA数据结构这一种语法是在软件层面的语法，硬件层面只有寄存器语法。</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230718155637140.png" alt="image-20230718155637140"></p><p>扯得有点远，还记得我们的目标是探索E1000的初始化过程，有了上面这些PCI的知识后，我们可以看一看PCI设备的寄存器是怎么映射到MMIO空间的。</p><p>补：PCI设备的地址。每个外设在PCI总线上都有一个地址。连接到总线上的PCI设备在总线枚举期间已经被分配了地址。</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230718210434516.png" alt="image-20230718210434516"></p><p>有了这个地址，我们就可以读写PCI Configuration space的寄存器了。</p><h3 id="关键数据结构与寄存器"><a href="#关键数据结构与寄存器" class="headerlink" title="关键数据结构与寄存器"></a>关键数据结构与寄存器</h3><p>为了实现DMA以及应对突发数据传输，E1000与驱动共同维护DMA Buffer。发送与接受使用不同的buffer，在这里分别进行描述。</p><h4 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h4><p>接受描述符recv_desc是描述接受缓冲区的关键描述符，它包含一个物理地址以及一系列描述字段。阴影部分由硬件接受后修改。当硬件受到报文，其将数据DMA到指定地址，同时填写相应的字段。描述符的实际存放位置是驱动分配的DMA内存。</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230718190725036.png" alt="image-20230718190725036"></p><p>与之对应的，Linux driver源码中数据结构如图所示。<img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230718195333660.png" alt="image-20230718195333660"></p><p>RDBAL和RDBAH两个寄存器存收包desc环的起始地址。RDH和RDT分别为头尾偏移量。实际上数据环是驱动软件层面维护的，硬件只需要通过这几个寄存器的值获得DMA数值。</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230718193153222.png" alt="image-20230718193153222"></p><p>理解：硬件直接DMA获得描述符实体，取出描述符后再通过指针取出中真正的数据buffer。其实就是DMA buffer的嵌套。</p><p>接受与发送，驱动一个创造空buffer一个创造有数据的buffer。</p><h4 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h4><p>基本与接受相同。这里说一下发送的时候驱动怎么操作寄存器。发送的时候，驱动在TX ring中添加一个描述符，并且写TDT寄存器。相对应的，硬件在写寄存器后会有相应的反应。下图是qemu的E1000 TDT寄存器写回调。可以看到圈出来的部分计算地址并且从内存DMA了这个desc。</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230718200845416.png" alt="image-20230718200845416"></p><h1 id="Case-Study-4：EHCI-Host-Controller-Driver-in-Linux"><a href="#Case-Study-4：EHCI-Host-Controller-Driver-in-Linux" class="headerlink" title="Case Study 4：EHCI Host Controller Driver in Linux"></a>Case Study 4：EHCI Host Controller Driver in Linux</h1><p>这篇<a href="https://blog.csdn.net/fudan_abc/category_338973.html">博客</a>写的真心不错。作者还写了许多Linux内核与设备驱动的文章，墙裂推荐。这里也只是对EHCI HCD部分的总结。这个博客关注的只为驱动层，没有关注到驱动与设备的交互层。</p><p><strong>EHCI首先是一个PCI设备，与E1000相似的内容我们不再赘述。</strong></p><p>EHCI HC的寄存器接口空间如下图所示：</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230718211011862.png" alt="image-20230718211011862"></p><h2 id="驱动在总线上的添加"><a href="#驱动在总线上的添加" class="headerlink" title="驱动在总线上的添加"></a>驱动在总线上的添加</h2><p>Linux中注册驱动或添加设备的过程：向总线添加driver或者device、遍历总线匹配、匹配成功则probe+bind。根据模块化设计，总线的probe最终会调用到一个具体driver的probe，这里最终是usb_hcd_pci_probe（）。</p><p>这个函数中的pci_enable_device()会对PCI配置空间进行读写操作，这里具体要参照设备Spec，是在<strong>寄存器Interface层次与设备的交互</strong>。另外这个函数还进行了一系列关键操作，比如映射PIO和MMIO空间、创建DMA池等等。之前UHCI的博客看了一些，不是很懂。但是这其实不是我们最需要关注的部分。</p><h2 id="EHCI驱动与设备的交互：语法"><a href="#EHCI驱动与设备的交互：语法" class="headerlink" title="EHCI驱动与设备的交互：语法"></a>EHCI驱动与设备的交互：语法</h2><p>这一部分才是我们最关注的内容。UHCI好像使用的比较少，而且比较古老，所以我们直接看EHCI。</p><p>”主机控制器的基本职责是创建TD并且将其连接到关键数据结构中，之后由硬件完成。“所以我们需要关注的关键内容是这些结构以及寄存器接口。</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230718224856004.png" alt="image-20230718224856004"></p><p>EHCI支持两种传输，异步（控制、bulk）与周期（同步、中断）传输。The periodic schedule与The asynchronous schedule是我们需要关注的对象。S 1.2.2讲的EHCI Schedule Data Structures没看懂。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>All Interrupt, Control and Bulk data streams are managed via queue heads (Section 3.6) and Queue Element Transfer Descriptors (qTDs described in Section 3.5)。 ——QH和TD的重要性</p><p>The periodic frame list is the root of all periodic (isochronous and interrupt transfer type) support for the host controller interface. The asynchronous list is the root for all the bulk and control transfer type support. ——两个list的重要性。</p><p>主机控制器最重要的一个职责是调度，在EHCI中这种调度就可以通过两种schedule实现。 ——体现了我对主机控制器的理解。</p><ol><li>Perodic frame list</li></ol><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230718225939634.png" alt="image-20230718225939634"></p><p>本质上是一个指针数组，大小可调。由两个operational寄存器索引。</p><p>每一个指针（FLLP）：</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230718230137779.png" alt="image-20230718230137779"></p><p>用一个32位指针指向下列数据结构中的一个，Typ表示类型。</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230718230724183.png" alt="image-20230718230724183"></p><p>总之就是，非常复杂！！</p><ol start="2"><li>TD *（这里其实已经不是EHCI了，因为EHCI太复杂，我这里看UHCI<a href="https://blog.csdn.net/fudan_abc/article/details/1852501">博客</a>进行一个大体上的理解）</li></ol><p>下图是UHCI的架构，我们重点关注TD QH以及其优先级。</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230718231258064.png" alt="image-20230718231258064"></p><p>​TD就是在USB总线上传输的数据包，注意USB本质上是一种协议，类似网络协议的数据分组，TD就是USB的分组。在UHCI中，TD分为Iso-TD（等时）和非等时TD，不同的传输类型（四种）、传输类型使用的TD、传输类型的优先级已经在图中得到体现。</p><ol start="3"><li>URB又是什么</li></ol><p>我的理解是，URB是HCD与设备完成交互的<strong>高层</strong>基本数据结构。所有的传输都从*usb_submit_urb()<em>函数开始，这个函数向USB提交一个URB。而URB具体怎么传输给设备，就要依赖上文的TD和QH了。比如在UHCI的bulk传输中，最终调用</em>uhci_submit_common()*会解构URB构建TD list。</p><h3 id="驱动与硬件的交互细节"><a href="#驱动与硬件的交互细节" class="headerlink" title="驱动与硬件的交互细节"></a>驱动与硬件的交互细节</h3><p>根据我的观察，UHCI与EHCI驱动与硬件交互的重点在软件层。也就是，驱动把相应的数据结构（TD QH）挂载到Frame List中就已经可以了。DMA的地址最开始由基址寄存器写入，之后则一直由一个索引寄存器比如EHCI的FriendEX自增索引。</p><h1 id="Case-Study-5：USB-xHCI-HC-与-HCD"><a href="#Case-Study-5：USB-xHCI-HC-与-HCD" class="headerlink" title="Case Study 5：USB xHCI HC 与 HCD"></a>Case Study 5：USB xHCI HC 与 HCD</h1><h2 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h2><p>可以看到和EHCI还有UHCI 差不多，有三个接口空间，两种USB传输类型（periodic 与 asychrounous）支持4种传输方式。值得注意的是xHCI使用同构（homogeneous）的方式进行各种传输，即这里的Transfer Ring。</p><p>xHCI HC管理设备的方式有点不同。引入了Device Slot和Door Bell的概念。每一个设备——》DCBAR种的一个entry，DB寄存器阵列中的一个reg，一个用于索引DCBAA的Slot ID。Device Slot指的是一个USB设备的相关数据结构（？）。TR是调度传输的关键数据结构。</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230719160522591.png" alt="image-20230719160522591"></p><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><ol><li>Device Context</li></ol><p>一个DC有32个数据结构，包括Slot Context（index &#x3D; 0），Endpoint Context。这个数据结构在设备枚举的时候创建，之后由xHC维护。有比较复杂的context，没看完。我觉得就是某个context索引了一个端点的transfer ring</p><ol start="2"><li>TR</li></ol><p>TR就是一个类似E1000中的循环队列。</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230719164023145.png" alt="image-20230719164023145"></p><p>这两个指针不是物理寄存器的。</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230719164042915.png" alt="image-20230719164042915"></p><p>注意TD可以由一个TRB或者多个TRB组成。</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230719164053052.png" alt="image-20230719164053052"></p><h2 id="传输细节"><a href="#传输细节" class="headerlink" title="传输细节"></a>传输细节</h2><ol><li>控制传输的例子</li></ol><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230719164422170.png" alt="image-20230719164422170"></p><p>我感觉就是把相关的TD放上去后按doorbell。</p><ol start="2"><li>命令环相关的操作</li></ol><p>感觉跟TR很像，把相关的TD放上去之后按0号门铃。</p><h1 id="Case-Study-6：Intel-HDA（audio）"><a href="#Case-Study-6：Intel-HDA（audio）" class="headerlink" title="Case Study 6：Intel HDA（audio）"></a>Case Study 6：Intel HDA（audio）</h1><p>整体架构：</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230719190528547.png" alt="image-20230719190528547"></p><p>流的概念：</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230719190514200.png" alt="image-20230719190514200"></p><p>这个比较正常，需要在内存中配置好流后配置一下CodeC，之后再写寄存器启动DMA。</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230719192406301.png" alt="image-20230719192406301"></p><h1 id="Case-Study-7：AHCI（storage）"><a href="#Case-Study-7：AHCI（storage）" class="headerlink" title="Case Study 7：AHCI（storage）"></a>Case Study 7：AHCI（storage）</h1><p>基本概念：AHCI是一种接口标准，用于软件和SATA设备交互。SATA是一种总线，基本负责和大容量存储设备的交互。所以我的理解是AHCI就是一种SATA总线的控制器，因为协议本质上就需要控制器（硬件）和驱动实现。同时最新的固态一般是通过NVMe协议（应该也是控制器）连接到PCIe上的，这里用的接口时M2或者U2。另外，最早期的硬盘应该是IDE标准，对应的有IDE控制器和IDE硬盘。IDE也就是ATA，现在基本上主板已经不再支持IDE（ATA），被SATA替代。</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230720204938515.png" alt="image-20230720204938515"></p><p>正式进入AHCI控制器。网上的可用资源很少，我倾向于直接看spec。</p><h2 id="架构概述"><a href="#架构概述" class="headerlink" title="架构概述"></a>架构概述</h2><p>首先AHCI是一种PCI设备，这让我想起了OSTEP中设备层次结构的这一张图：</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230720210541963.png" alt="image-20230720210541963"></p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230720210635810.png" alt="image-20230720210635810"></p><p>有种豁然开朗的感觉。SATA控制器把SATA总线连到AHCI上，AHCI是一种协议或者标准，而SATA控制器实现了这种协议。QEMU中的这个ahci.c我觉得应该就是SATA控制器。Spec中的HBA我认为就是控制器。</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230720211656651.png" alt="image-20230720211656651"></p><p>spec中的这个图也很好理解了：</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230720211501124.png" alt="image-20230720211501124"></p><p>HBA卡桥接了SATA总线和PCI总线。</p><h2 id="AHCI传输方式概览"><a href="#AHCI传输方式概览" class="headerlink" title="AHCI传输方式概览"></a>AHCI传输方式概览</h2><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230720213910260.png" alt="image-20230720213910260"></p><p>这里给出了一个基本的模式。看上去传输也是把相关的数据结构放进去之后用寄存器通知。</p><p>1.7节有不少信息。</p><p>注意，重要的数据单元FIS，用于在SATA设备和内存之间传递数据以及控制信息。</p><h2 id="寄存器Interface"><a href="#寄存器Interface" class="headerlink" title="寄存器Interface"></a>寄存器Interface</h2><p>寄存器分为全局寄存器和每个端口的控制寄存器（这里说的是一个HBA硬件），一个端口对应一系列端口寄存器，都是相同的。</p><ul><li>全局寄存器</li></ul><p>不看了</p><ul><li>端口寄存器</li></ul><p>每一个端口的起始地址计算规则是这样：</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230720214808786.png" alt="image-20230720214808786"></p><h2 id="内存空间Interface"><a href="#内存空间Interface" class="headerlink" title="内存空间Interface"></a>内存空间Interface</h2><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230720220123702.png" alt="image-20230720220123702"></p><p>每一个port的控制寄存器指向了一段内存空间。一个port有一个FIS描述符列表和一个命令列表，每一个端口的相关数据结构如下图。</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230720220800108.png" alt="image-20230720220800108"></p><p>对于FIS空间，存放来自设备的FIS。</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230720220549111.png" alt="image-20230720220549111"></p><p>这个Command Table（如下图）里面应该有指向内存中数据区的指针。</p><p><img src="C:\Users\jiangshao\AppData\Roaming\Typora\typora-user-images\image-20230720220922535.png" alt="image-20230720220922535"></p><h2 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h2><p>这里集中在5.1，5.5，和5.6。可以说非常复杂，还有极其复杂的状态机。</p><p>这种复杂性说明了我猜想的正确性：现有的方法太过简单。</p><p>q：能不能由这个例子启发状态机？参考NSFuzz的思路。如果要做，首先要通过spec知道设备有没有状态，其次要看源码状态是怎么是怎么实现的，之后需要看状态的实现方式有没有共性，最后确定状态如何提取和利用。</p><h1 id="What-we-get？"><a href="#What-we-get？" class="headerlink" title="What we get？"></a>What we get？</h1><p>软件层grammar与寄存器层grammar之间的引用关系很复杂。现有的方法没法处理或者过于简单化。比如某一个寄存器放基地址，另一个基地址存放索引的Index。</p><p>难以主动触发争取的硬件行为。比如V-S只是随机写寄存器。</p><p>比如E1000，</p><p>网卡是不是有两层地址引用？MundoFuzz处理地址的方法太简单了。</p><p>搞清楚网卡的数据包怎么放到内存。</p><p>我们要关注软件层面语法于寄存器层面语法的联系。软件层面非常复杂。</p><p>挑战：</p><p>驱动程序庞大复杂，如何识别、区分出与Fuzzing设备相关的有效部分。</p><p>现有的自动推断方法，导致了可拓展性，XXX性的下降。</p><p>有没有必要在内存中还原出完整地数据结构？？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;At the lowest level, a piece of software in the OS must know in detail&lt;br&gt;how a device works. We call this piece of software</summary>
      
    
    
    
    
    <category term="Device Driver" scheme="http://example.com/tags/Device-Driver/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2023/07/17/hello-world/"/>
    <id>http://example.com/2023/07/17/hello-world/</id>
    <published>2023-07-17T10:47:41.880Z</published>
    <updated>2023-07-17T11:14:43.205Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start-js"><a href="#Quick-Start-js" class="headerlink" title="Quick Start - js"></a>Quick Start - js</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
